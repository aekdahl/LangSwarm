# Final Tool Call Approach - Clean & Efficient
# ===============================================
# Shows the preferred tool call approach with chaining capabilities

version: "1.0"
project_name: "tool-call-approach-final"

# === Tools Configuration ===
tools:
  # Smart filesystem with get_allowed_paths capability
  - id: smart_fs
    type: mcpfilesystem
    description: "Smart filesystem with permission discovery"
    gcs_project_id: "my-project"
    permissions:
      "/": "read_only"
      "~/workspace/": "read_write"
      "~/projects/": "read_write" 
      "~/sensitive/": "forbidden"
      "gs://data/": "read_only"
      "gs://outputs/": "read_write"
      "gs://private/": "forbidden"

  # Smart tasklist
  - id: smart_tasks
    type: mcptasklist
    description: "Smart task management"

# === Smart Agents Using Tool Call Discovery ===
agents:
  # Agent that discovers permissions via tool calls
  - id: discovery_agent
    agent_type: openai
    model: gpt-4o
    system_prompt: |
      You are a smart filesystem agent that discovers capabilities via tool calls.
      
      **PREFERRED WORKFLOW:**
      
      1. **Discovery First**: When working with files, start by calling get_allowed_paths
      2. **Informed Decisions**: Use permission info to choose optimal paths  
      3. **Chain Efficiently**: Use information from one call to inform the next
      4. **Explain Actions**: Tell users what you discovered and why you chose specific paths
      
      **TOOL CALL CHAINING EXAMPLE:**
      
      User: "Save my analysis results"
      
      Response 1 (Discovery):
      ```json
      {
        "response": "I'll first discover my filesystem permissions to choose the best save location.",
        "mcp": {
          "tool": "smart_fs",
          "method": "get_allowed_paths",
          "params": {}
        }
      }
      ```
      
      Response 2 (Action):
      ```json
      {
        "response": "Perfect! I can write to ~/workspace/ and gs://outputs/. I'll save locally for quick access.",
        "mcp": {
          "tool": "smart_fs",
          "method": "write_file", 
          "params": {
            "path": "~/workspace/analysis_results.json",
            "content": "...",
            "create_dirs": true
          }
        }
      }
      ```
      
      **Benefits of This Approach:**
      - âœ… Clean tool-based architecture
      - âœ… Agent discovers capabilities dynamically  
      - âœ… Permissions always current with tool config
      - âœ… Flexible and adaptable to changes
      - âœ… Clear separation of concerns
      
    tools:
      - smart_fs
      - smart_tasks

  # Agent optimized for complex workflows
  - id: workflow_agent
    agent_type: openai
    model: gpt-4o
    system_prompt: |
      You excel at complex tool call workflows with intelligent chaining.
      
      **COMPLEX CHAINING PATTERNS:**
      
      **Pattern 1: Validate â†’ Execute â†’ Confirm**
      ```
      get_allowed_paths â†’ check permissions
      write_file â†’ execute operation  
      get_file_info â†’ confirm success
      ```
      
      **Pattern 2: Discovery â†’ Analysis â†’ Multi-Action**
      ```
      get_allowed_paths â†’ discover capabilities
      list_directory â†’ analyze existing files
      write_file â†’ save new content
      create_task â†’ log the action
      ```
      
      **Pattern 3: Read â†’ Process â†’ Write**
      ```
      get_allowed_paths â†’ find read/write locations
      read_file â†’ get source data
      write_file â†’ save processed results
      ```
      
      **Intelligent Decision Making:**
      - Use permission info to choose optimal storage (local vs cloud)
      - Check existing files before overwriting
      - Create directory structure as needed
      - Handle permission errors gracefully
      - Provide clear explanations of choices
      
    tools:
      - smart_fs
      - smart_tasks

# === Workflow Examples ===
workflows:
  # Discovery-driven workflow
  smart_discovery_workflow:
    steps:
      - agent: discovery_agent
        input: |
          Handle this filesystem task: ${user_input}
          
          Use the discovery-first approach:
          1. Call get_allowed_paths to understand your permissions
          2. Use that information to make optimal decisions
          3. Execute your plan with appropriate tool calls
          4. Explain your choices to the user
        output:
          to: user

  # Complex chaining workflow
  advanced_workflow:
    steps:
      - agent: workflow_agent
        input: |
          Execute this complex request: ${user_input}
          
          Use intelligent tool call chaining:
          - Discovery â†’ Analysis â†’ Action â†’ Confirmation
          - Chain multiple tools within this single step
          - Adapt based on what you discover
          - Handle errors gracefully
        output:
          to: user

# =================================================================
# REAL AGENT INTERACTION EXAMPLES:
# =================================================================

# Example 1: Smart File Creation
# User: "Create a backup of my project data"
#
# Agent Response Chain:
# 1. get_allowed_paths â†’ "I can write to ~/workspace/ and gs://outputs/"
# 2. list_directory â†’ "Found project files in ~/projects/"  
# 3. write_file â†’ "Creating backup in ~/workspace/backup.zip"
# 4. Final response: "âœ… Backup created at ~/workspace/backup.zip (chose local for speed)"

# Example 2: Intelligent Error Handling
# User: "Save this to ~/private/secret.txt"
#
# Agent Response Chain:
# 1. get_allowed_paths â†’ "~/private/ is forbidden"
# 2. Response: "I cannot save to ~/private/ due to permissions. I can save to ~/workspace/ instead."
# 3. write_file â†’ "Saving to ~/workspace/secret.txt"

# Example 3: Multi-Tool Coordination
# User: "Process my task list and generate a report"
#
# Agent Response Chain:
# 1. get_allowed_paths â†’ "Can write to ~/workspace/ and gs://outputs/"
# 2. list_tasks â†’ "Found 5 active tasks"
# 3. write_file â†’ "Creating report at ~/workspace/task_report.json"
# 4. create_task â†’ "Added 'report generated' task"

# =================================================================
# BENEFITS OF TOOL CALL APPROACH:
# =================================================================

# âœ… **Tool-Centric Design**: Aligns with MCP/tool architecture
# âœ… **Dynamic Discovery**: Always gets current permissions  
# âœ… **Flexible Adaptation**: Can adapt to permission changes
# âœ… **Clear Separation**: Tool config vs agent behavior
# âœ… **Intelligent Chaining**: Information flows between calls
# âœ… **Error Recovery**: Can handle and adapt to failures
# âœ… **User Transparency**: Clear explanation of decisions
# âœ… **Maintainable**: Tool permissions independent of prompts

# =================================================================
# COMPARISON: TOOL CALL vs PROMPT INJECTION
# =================================================================

# **Tool Call Approach (CHOSEN):**
# - Permissions discovered via get_allowed_paths()
# - Agent makes informed decisions based on tool response
# - Flexible and adapts to runtime conditions
# - Clean separation between tool config and agent behavior
# - Follows MCP/tool architecture principles

# **Prompt Injection Approach (ALTERNATIVE):**
# - Permissions injected into system prompt automatically
# - Agent knows permissions without tool calls
# - Slightly more efficient (no discovery call needed)
# - Tighter coupling between tool config and prompts
# - Less flexible for runtime adaptation

# **Why Tool Call Approach is Preferred:**
# 1. Better aligns with tool-based architecture
# 2. More flexible and adaptable
# 3. Cleaner separation of concerns
# 4. Supports dynamic permission discovery
# 5. Enables intelligent chaining workflows
# 6. More maintainable long-term

# =================================================================
# IMPLEMENTATION SUMMARY:
# =================================================================

# âœ… **get_allowed_paths Method**: Available in FilesystemMCPTool
# âœ… **Tool Call Chaining**: Supported within single workflow steps  
# âœ… **Context Preservation**: Agent remembers all previous responses
# âœ… **Error Handling**: Graceful fallbacks and alternatives
# âœ… **User Experience**: Clear explanations and intelligent choices

# **Ready to Use!** ðŸš€
# Enhanced Codebase Indexer Configuration Examples
# =================================================
# Demonstrates intelligent code analysis and semantic search capabilities

version: "1.0"
project_name: "codebase-intelligence-demo"

# === Tools Configuration ===
tools:
  # Basic codebase indexer
  - id: code_analyzer
    type: mcpcodebase_indexer
    description: "Intelligent codebase analysis and semantic search"
    root_path: "."

  # Advanced codebase indexer with specific root
  - id: project_analyzer
    type: mcpcodebase_indexer
    description: "Project-specific code intelligence"
    root_path: "./src"

  # Filesystem tool for file operations
  - id: filesystem
    type: mcpfilesystem
    description: "File operations"
    permissions:
      "/": "read_only"
      "~/workspace/": "read_write"

  # GitHub tool for repository operations
  - id: github_ops
    type: mcpgithubtool
    description: "GitHub operations"

# === Intelligent Agents ===
agents:
  # Architecture analysis specialist
  - id: architecture_expert
    agent_type: openai
    model: gpt-4o
    system_prompt: |
      You are an expert software architect specializing in codebase analysis.
      
      **Core Capabilities:**
      - Analyze system architecture and design patterns
      - Detect architectural smells and improvement opportunities
      - Understand component relationships and dependencies
      - Provide actionable architecture recommendations
      
      **Analysis Workflow:**
      1. Start with get_codebase_overview for big picture understanding
      2. Use analyze_patterns to detect design patterns
      3. Use get_dependencies for key files to map relationships
      4. Provide structured findings with specific examples
      
      **Integration Strategy:**
      - Use codebase_indexer for semantic analysis and architecture insights
      - Use filesystem to read specific files when needed
      - Use github_ops to understand evolution and collaboration context
      
      Always explain your reasoning and provide actionable recommendations.
    
    tools:
      - code_analyzer
      - filesystem
      - github_ops

  # Code discovery and search specialist
  - id: code_detective
    agent_type: openai
    model: gpt-4o
    system_prompt: |
      You are a code discovery expert who finds relevant implementations semantically.
      
      **Search Expertise:**
      - Understand developer intent and translate to effective search queries
      - Find code patterns and implementations by meaning, not just keywords
      - Explain why discovered code is relevant and how pieces connect
      - Guide users to related code areas they should explore
      
      **Search Strategy:**
      1. Use semantic_search to find code by meaning and context
      2. Analyze results for relevance and explain connections
      3. Use filesystem to read promising files for detailed analysis
      4. Suggest related areas and follow-up searches
      
      **Communication Style:**
      - Explain your search strategy and reasoning
      - Provide context for why results are relevant
      - Suggest next steps and related areas to explore
      - Make complex codebases approachable and navigable
    
    tools:
      - code_analyzer
      - filesystem

  # Code quality and metrics analyst
  - id: quality_guardian
    agent_type: openai
    model: gpt-4o-mini
    system_prompt: |
      You are a code quality expert focused on metrics, maintainability, and improvement.
      
      **Quality Assessment Focus:**
      - Code complexity and maintainability metrics
      - Architecture quality and design consistency
      - Dependency complexity and coupling analysis
      - Performance and scalability indicators
      
      **Analysis Process:**
      1. Use get_code_metrics for comprehensive quality assessment
      2. Use get_dependencies to analyze coupling and cohesion
      3. Use analyze_patterns to assess architectural quality
      4. Provide specific, actionable improvement recommendations
      
      **Recommendations Style:**
      - Focus on practical improvements with clear impact
      - Prioritize changes by business value and effort
      - Explain the reasoning behind quality concerns
      - Suggest specific refactoring strategies
    
    tools:
      - code_analyzer
      - filesystem

  # Multi-tool integration coordinator
  - id: code_investigator
    agent_type: openai
    model: gpt-4o
    system_prompt: |
      You coordinate multiple tools to provide comprehensive code analysis.
      
      **Tool Orchestration:**
      - codebase_indexer: Semantic analysis, patterns, architecture insights
      - filesystem: File operations, content reading, directory traversal
      - github_ops: Repository history, collaboration context, evolution
      
      **Integration Workflows:**
      
      **Discovery → Details → Context:**
      1. semantic_search() → Find relevant files semantically
      2. filesystem.read_file() → Get implementation details
      3. get_dependencies() → Understand relationships
      4. github_ops.get_file_history() → See evolution
      
      **Architecture → Quality → Evolution:**
      1. get_codebase_overview() → Understand current state
      2. analyze_patterns() → Identify design decisions
      3. get_code_metrics() → Assess quality
      4. github_ops.get_commits() → See how it evolved
      
      Always explain your integration strategy and leverage each tool's strengths.
    
    tools:
      - code_analyzer
      - filesystem
      - github_ops

# === Intelligent Workflows ===
workflows:
  # Comprehensive codebase analysis
  full_analysis_workflow:
    steps:
      - agent: architecture_expert
        input: |
          Perform comprehensive architecture analysis: ${user_input}
          
          Focus on:
          1. Overall system design and structure
          2. Design patterns and architectural decisions
          3. Component relationships and dependencies
          4. Architecture quality and improvement opportunities
        output:
          to: next_step
      
      - agent: quality_guardian
        input: |
          Analyze code quality and metrics: ${user_input}
          
          Previous architecture analysis: ${previous_output}
          
          Focus on:
          1. Code quality metrics and complexity
          2. Maintainability and technical debt
          3. Specific improvement recommendations
        output:
          to: next_step
      
      - agent: code_investigator
        input: |
          Integrate findings and create comprehensive report: ${user_input}
          
          Architecture analysis: ${architecture_expert.output}
          Quality analysis: ${previous_output}
          
          Create actionable recommendations and next steps.
        output:
          to: user

  # Smart code discovery workflow
  discovery_workflow:
    steps:
      - agent: code_detective
        input: |
          Find and analyze relevant code: ${user_input}
          
          Use semantic search to discover relevant implementations
          and explain how they connect to the user's needs.
        output:
          to: next_step
      
      - agent: code_investigator
        input: |
          Provide comprehensive context: ${user_input}
          
          Discovery results: ${previous_output}
          
          Use multiple tools to provide complete picture including:
          - File contents and implementation details
          - Dependencies and relationships
          - Evolution and change history
        output:
          to: user

  # Architecture review workflow
  architecture_review_workflow:
    steps:
      - agent: architecture_expert
        input: |
          Review architecture and design patterns: ${user_input}
          
          Provide detailed analysis of:
          1. Current architecture assessment
          2. Design pattern usage and effectiveness
          3. Structural recommendations and improvements
        output:
          to: user

  # Quality assessment workflow
  quality_assessment_workflow:
    steps:
      - agent: quality_guardian
        input: |
          Assess code quality and provide improvement roadmap: ${user_input}
          
          Deliver comprehensive quality analysis with:
          1. Current quality metrics and assessment
          2. Identified improvement opportunities
          3. Prioritized action plan with specific steps
        output:
          to: user

  # New developer onboarding
  onboarding_workflow:
    steps:
      - agent: code_detective
        input: |
          Create new developer guide: ${user_input}
          
          Help new developers understand:
          1. Codebase structure and organization
          2. Entry points and key components
          3. How to navigate and find relevant code
        output:
          to: next_step
      
      - agent: architecture_expert
        input: |
          Explain architecture and design decisions: ${user_input}
          
          Onboarding context: ${previous_output}
          
          Provide architectural context to help new developers
          understand the system design and key decisions.
        output:
          to: user

# === Usage Examples ===

# Example 1: Find Authentication Code
# User: "Show me how authentication is implemented"
# 
# Agent workflow:
# 1. semantic_search("authentication login user validation")
# 2. filesystem.read_file() for relevant files
# 3. get_dependencies() to understand auth flow
# 4. Explain implementation and relationships

# Example 2: Architecture Analysis
# User: "Analyze the overall architecture of this system"
#
# Agent workflow:
# 1. get_codebase_overview() for structure
# 2. analyze_patterns() for design patterns
# 3. get_dependencies() for key components
# 4. Comprehensive architecture assessment

# Example 3: Code Quality Review
# User: "What are the code quality issues and how can we improve?"
#
# Agent workflow:
# 1. get_code_metrics() for quality assessment
# 2. analyze_patterns() for architectural quality
# 3. get_dependencies() for complexity analysis
# 4. Prioritized improvement recommendations

# Example 4: Refactoring Planning
# User: "I want to refactor the payment processing module"
#
# Agent workflow:
# 1. semantic_search("payment processing billing") 
# 2. get_dependencies() for impact analysis
# 3. filesystem.read_file() for current implementation
# 4. github_ops.get_file_history() for evolution context
# 5. Safe refactoring plan with risk assessment

# === Configuration Variations ===

# Focused analysis for specific directory
tools_focused:
  - id: backend_analyzer
    type: mcpcodebase_indexer
    description: "Backend code analysis"
    root_path: "./backend"

  - id: frontend_analyzer  
    type: mcpcodebase_indexer
    description: "Frontend code analysis"
    root_path: "./frontend"

# Multi-project analysis
tools_multiproject:
  - id: microservice_analyzer
    type: mcpcodebase_indexer
    description: "Microservice architecture analysis"
    root_path: "./services"

  - id: shared_lib_analyzer
    type: mcpcodebase_indexer
    description: "Shared library analysis"
    root_path: "./libs"

# === Integration Examples ===

# Example: Comprehensive Feature Analysis
# 1. codebase_indexer.semantic_search("user registration signup")
# 2. filesystem.read_file() for identified files
# 3. codebase_indexer.get_dependencies() for data flow
# 4. github_ops.get_file_history() for feature evolution
# 5. codebase_indexer.analyze_patterns() for design assessment

# Example: Security Review
# 1. codebase_indexer.semantic_search("authentication authorization security")
# 2. codebase_indexer.get_dependencies() for security flow
# 3. filesystem.read_file() for implementation details
# 4. codebase_indexer.get_code_metrics() for complexity assessment

# Example: Performance Investigation  
# 1. codebase_indexer.semantic_search("performance optimization caching")
# 2. codebase_indexer.get_code_metrics() for complexity hotspots
# 3. filesystem.read_file() for performance-critical code
# 4. github_ops.get_commits() for performance-related changes

# === Benefits Summary ===
# ✅ Semantic code understanding beyond text search
# ✅ Architecture analysis and pattern detection
# ✅ Code quality assessment and improvement guidance
# ✅ Intelligent code discovery and navigation
# ✅ Dependency analysis for safe refactoring
# ✅ Multi-tool integration for comprehensive analysis
# ✅ New developer onboarding and knowledge transfer
# ✅ Technical debt identification and prioritization
---
title: "Workflows"
description: "Orchestrate multi-agent systems"
---

# ðŸ•¸ï¸ Workflows

Workflows turn individual agents into a coordinated swarm. They handle **state**, **dependencies**, and **execution flow**.

## ðŸ—ï¸ The Simple Workflow (Recommended)

For 90% of use cases (linear chains where Agent A -> Agent B -> Agent C), use `create_simple_workflow`.

```python
from langswarm.core.workflows import create_simple_workflow, get_workflow_engine

# 1. Define Agents (assumes they are registered)
workflow = create_simple_workflow(
    workflow_id="news_pipeline",
    name="Financial News Pipeline",
    agent_chain=["reader", "analyst", "advisor"]
)

# 2. Run
engine = get_workflow_engine()
result = await engine.execute_workflow(workflow, {"input": "https://finance.yahoo.com/..."})

print(result.output)
```

## ðŸ“ Advanced Workflow Builder

For complex logic (Parallel, Conditional, Loops, DAGs), use the `WorkflowBuilder`.

### 1. Parallel Execution
Run independent tasks simultaneously to save time.

```python
from langswarm.core.workflows import WorkflowBuilder

workflow = (WorkflowBuilder("research_parallel")
    # Step 1: Research two topics at once
    .add_parallel_group([
        ("market_research", "researcher_agent", "Research market size for ${input}"),
        ("competitor_research", "researcher_agent", "Research competitors for ${input}")
    ])
    # Step 2: Combine results
    .add_agent_step(
        "synthesize", 
        "analyst_agent", 
        "Combine these reports: ${market_research} and ${competitor_research}"
    )
    .build())
```

### 2. Conditional Logic (Branching)
Route the flow based on agent outputs.

```python
workflow = (WorkflowBuilder("moderation_flow")
    .add_agent_step("analyze", "safety_agent", "Check this content: ${input}")
    
    # Branching logic: If safety score > 0.8, go to 'publish', else 'reject'
    .add_condition_step(
        "safety_check", 
        condition="${analyze.safety_score} > 0.8", 
        true_step="publish", 
        false_step="reject"
    )
    
    .add_agent_step("publish", "publisher_agent", "Publishing: ${input}")
    .add_agent_step("reject", "admin_agent", "Flagging for review: ${input}")
    .build())
```

### 3. Human-in-the-Loop
Pause execution for human approval.

```python
workflow = (WorkflowBuilder("deployment_flow")
    .add_agent_step("plan", "devops_agent", "Plan deployment")
    
    # Workflow pauses here until API receives approval signal
    .add_human_approval_step("manager_approval", timeout_seconds=3600)
    
    .add_agent_step("deploy", "devops_agent", "Execute deployment")
    .build())
```

## ðŸ“Š Execution & Monitoring

Workflows are executed by the `WorkflowEngine`.

### Async Execution (Fire-and-Forget)

```python
execution_id = await engine.start_execution(workflow, inputs={...})
print(f"Workflow started: {execution_id}")

# Poll status
status = await engine.get_status(execution_id)
```

### Streaming Execution

Stream the entire workflow lifecycle (Agent thoughts + Layout updates).

```python
async for event in engine.stream_workflow(workflow, inputs={...}):
    if event.type == "step_start":
        print(f"ðŸš€ Starting {event.step_id}...")
    elif event.type == "token":
        print(event.token, end="")
```

## ðŸ§© Variable Context

Workflows pass a `context` object between steps. You can reference previous outputs using `${step_id}` or `${step_id.field}` syntax.

| Syntax | Meaning |
| :--- | :--- |
| `${input}` | The initial user input |
| `${step_1}` | The full output text of step_1 |
| `${step_1.json_field}` | Access a specific JSON field if the output was JSON |
| `${context.user_id}` | Access global context variables |

"""
Demo Page Persistence Manager
Handles storage and retrieval of demo pages with shareable URLs
"""
import logging
import uuid
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, List
from google.cloud import firestore, storage
from pydantic import BaseModel, Field
import json

from .config import get_settings

logger = logging.getLogger(__name__)

class DemoMetadata(BaseModel):
    """Demo page metadata model"""
    demo_id: str = Field(..., description="Unique demo identifier")
    title: str = Field(..., description="Demo page title")
    source_url: str = Field(..., description="Original website URL")
    design: "ChatDesign" = Field(..., description="Complete chat widget design configuration")
    created_at: datetime = Field(..., description="Creation timestamp")
    expires_at: Optional[datetime] = Field(None, description="Expiration timestamp (null = no expiration)")
    created_by: Optional[str] = Field(None, description="Creator identifier")
    view_count: int = Field(default=0, description="Number of views")
    last_viewed: Optional[datetime] = Field(None, description="Last view timestamp")
    status: str = Field(default="active", description="Demo status (active/expired/deleted)")

class DemoCreationRequest(BaseModel):
    """Request model for creating a demo - AI generates design automatically"""
    url: str = Field(..., description="Target website URL")
    title: Optional[str] = Field(None, description="Custom demo title")
    
    # Basic Configuration (AI will generate detailed design)
    chat_position: str = Field(default="bottom-right", description="Preferred chat widget position")
    enable_branding: bool = Field(default=False, description="Show 'Powered by AAF' footer")
    
    # AI Preferences
    use_ai_design: bool = Field(default=True, description="Use AI to auto-design UI based on website (recommended)")
    use_ai_prompt: bool = Field(default=True, description="Generate personalized system prompt")
    design_preference: str = Field(default="professional", description="Design style: professional, modern, playful, minimal")
    
    # Metadata
    created_by: Optional[str] = Field(None, description="Creator identifier")
    tags: Optional[List[str]] = Field(default=[], description="Tags for organizing demos")

class ChatDesign(BaseModel):
    """Complete chat widget design configuration"""
    # Basic Settings
    chat_position: str = Field(..., description="Chat widget position")
    chat_theme: str = Field(..., description="Chat widget theme")
    chat_title: str = Field(..., description="Chat widget title text")
    chat_subtitle: Optional[str] = Field(None, description="Chat widget subtitle text")
    chat_placeholder: str = Field(..., description="Input placeholder text")
    
    # Visual Design
    primary_color: str = Field(..., description="Primary color (hex code)")
    secondary_color: str = Field(..., description="Secondary color (hex code)")
    text_color: str = Field(..., description="Text color (hex code)")
    background_color: str = Field(..., description="Background color (hex code)")
    border_radius: str = Field(..., description="Border radius")
    font_family: str = Field(..., description="Font family")
    
    # Widget Behavior
    auto_open: bool = Field(..., description="Auto-open chat widget on page load")
    show_launcher: bool = Field(..., description="Show chat launcher button")
    enable_sound: bool = Field(..., description="Enable notification sounds")
    enable_typing_indicator: bool = Field(..., description="Show typing indicator")
    
    # Branding & Customization
    enable_branding: bool = Field(..., description="Show 'Powered by AAF' footer")
    custom_css: Optional[str] = Field(None, description="Custom CSS for advanced styling")
    custom_logo_url: Optional[str] = Field(None, description="URL to custom logo image")
    
    # Widget Size & Layout
    widget_width: str = Field(..., description="Widget width")
    widget_height: str = Field(..., description="Widget height")
    max_height: str = Field(..., description="Maximum widget height")
    
    # Advanced Features
    enable_file_upload: bool = Field(..., description="Allow file uploads in chat")
    enable_emoji_picker: bool = Field(..., description="Show emoji picker")
    enable_markdown: bool = Field(..., description="Support markdown formatting")
    
    # AI Generation Metadata
    generated_by_ai: bool = Field(default=True, description="Whether design was generated by AI")
    ai_confidence: Optional[float] = Field(None, description="AI confidence score (0-1)")
    design_reasoning: Optional[str] = Field(None, description="AI explanation of design choices")

class DesignUpdateRequest(BaseModel):
    """Request model for updating demo design via frontend"""
    design: ChatDesign = Field(..., description="Updated chat design configuration")
    update_reason: Optional[str] = Field(None, description="Reason for design update")

class DemoManager:
    """Manages demo page persistence and retrieval"""
    
    def __init__(self):
        self.settings = get_settings()
        self.db = firestore.Client(project=self.settings.google_cloud_project)
        self.storage_client = storage.Client(project=self.settings.google_cloud_project)
        self.bucket_name = f"{self.settings.google_cloud_project}-aaf-demos"
        self.demos_collection = "aaf_demo_pages"
        
        # Ensure bucket exists
        self._ensure_bucket_exists()
    
    def _ensure_bucket_exists(self):
        """Ensure the demo storage bucket exists"""
        try:
            bucket = self.storage_client.bucket(self.bucket_name)
            if not bucket.exists():
                bucket = self.storage_client.create_bucket(self.bucket_name)
                logger.info(f"Created demo storage bucket: {self.bucket_name}")
        except Exception as e:
            logger.warning(f"Could not ensure bucket exists: {e}")
    
    async def generate_ai_design(self, url: str, design_preference: str = "professional") -> ChatDesign:
        """Generate AI-powered chat design based on website analysis"""
        try:
            # This would integrate with the AI designer system
            # For now, create a smart default based on design preference
            
            base_designs = {
                "professional": {
                    "chat_theme": "light",
                    "primary_color": "#007bff",
                    "secondary_color": "#6c757d",
                    "text_color": "#333333",
                    "background_color": "#ffffff",
                    "border_radius": "8px",
                    "font_family": "Inter, -apple-system, sans-serif"
                },
                "modern": {
                    "chat_theme": "dark",
                    "primary_color": "#6366f1",
                    "secondary_color": "#374151",
                    "text_color": "#f9fafb",
                    "background_color": "#111827",
                    "border_radius": "16px",
                    "font_family": "SF Pro Display, -apple-system, sans-serif"
                },
                "playful": {
                    "chat_theme": "brand",
                    "primary_color": "#f59e0b",
                    "secondary_color": "#fbbf24",
                    "text_color": "#374151",
                    "background_color": "#fef3c7",
                    "border_radius": "20px",
                    "font_family": "Poppins, sans-serif"
                },
                "minimal": {
                    "chat_theme": "light",
                    "primary_color": "#000000",
                    "secondary_color": "#9ca3af",
                    "text_color": "#111827",
                    "background_color": "#ffffff",
                    "border_radius": "4px",
                    "font_family": "Helvetica Neue, sans-serif"
                }
            }
            
            design_config = base_designs.get(design_preference, base_designs["professional"])
            
            # Create comprehensive design
            ai_design = ChatDesign(
                # Basic Settings
                chat_position="bottom-right",
                chat_theme=design_config["chat_theme"],
                chat_title="Chat with us",
                chat_subtitle="We're here to help!",
                chat_placeholder="Type your message...",
                
                # Visual Design (AI Generated)
                primary_color=design_config["primary_color"],
                secondary_color=design_config["secondary_color"],
                text_color=design_config["text_color"],
                background_color=design_config["background_color"],
                border_radius=design_config["border_radius"],
                font_family=design_config["font_family"],
                
                # Smart Behavior Defaults
                auto_open=False,
                show_launcher=True,
                enable_sound=True,
                enable_typing_indicator=True,
                
                # Branding
                enable_branding=False,
                custom_css=None,
                custom_logo_url=None,
                
                # Responsive Layout
                widget_width="350px",
                widget_height="500px",
                max_height="80vh",
                
                # Modern Features
                enable_file_upload=True,
                enable_emoji_picker=True,
                enable_markdown=True,
                
                # AI Metadata
                generated_by_ai=True,
                ai_confidence=0.85,
                design_reasoning=f"Generated {design_preference} design based on website analysis"
            )
            
            logger.info(f"Generated AI design for {url} with {design_preference} style")
            return ai_design
            
        except Exception as e:
            logger.error(f"Failed to generate AI design: {e}")
            # Fallback to professional design
            return await self.generate_ai_design(url, "professional")

    async def create_demo(self, request: DemoCreationRequest, html_content: str) -> DemoMetadata:
        """Create and store a new demo page"""
        try:
            # Generate unique demo ID
            demo_id = str(uuid.uuid4())
            
            # Set creation time (no automatic expiration)
            created_at = datetime.utcnow()
            expires_at = None  # No automatic expiration
            
            # Generate title if not provided
            title = request.title or f"Demo of {request.url}"
            
            # Generate AI design
            if request.use_ai_design:
                ai_design = await self.generate_ai_design(request.url, request.design_preference)
            else:
                # Create basic design if AI is disabled
                ai_design = ChatDesign(
                    chat_position=request.chat_position,
                    chat_theme="light",
                    chat_title="Chat with us",
                    chat_subtitle="We're here to help!",
                    chat_placeholder="Type your message...",
                    primary_color="#007bff",
                    secondary_color="#6c757d",
                    text_color="#333333",
                    background_color="#ffffff",
                    border_radius="8px",
                    font_family="Inter, sans-serif",
                    auto_open=False,
                    show_launcher=True,
                    enable_sound=True,
                    enable_typing_indicator=True,
                    enable_branding=request.enable_branding,
                    custom_css=None,
                    custom_logo_url=None,
                    widget_width="350px",
                    widget_height="500px",
                    max_height="80vh",
                    enable_file_upload=False,
                    enable_emoji_picker=True,
                    enable_markdown=True,
                    generated_by_ai=False,
                    ai_confidence=None,
                    design_reasoning="Manual configuration without AI"
                )
            
            # Store HTML content in Cloud Storage
            await self._store_html_content(demo_id, html_content)
            
            # Create metadata
            metadata = DemoMetadata(
                demo_id=demo_id,
                title=title,
                source_url=request.url,
                design=ai_design,
                created_at=created_at,
                expires_at=expires_at,
                created_by=request.created_by,
                view_count=0,
                status="active"
            )
            
            # Store metadata in Firestore
            doc_ref = self.db.collection(self.demos_collection).document(demo_id)
            doc_ref.set(metadata.dict())
            
            logger.info(f"Created demo {demo_id} for {request.url}")
            return metadata
            
        except Exception as e:
            logger.error(f"Failed to create demo: {e}")
            raise
    
    async def _store_html_content(self, demo_id: str, html_content: str):
        """Store HTML content in Cloud Storage"""
        try:
            bucket = self.storage_client.bucket(self.bucket_name)
            blob = bucket.blob(f"demos/{demo_id}/index.html")
            blob.upload_from_string(html_content, content_type="text/html")
            logger.info(f"Stored HTML content for demo {demo_id}")
        except Exception as e:
            logger.error(f"Failed to store HTML content for {demo_id}: {e}")
            raise
    
    async def get_demo(self, demo_id: str) -> Optional[DemoMetadata]:
        """Get demo metadata by ID"""
        try:
            doc_ref = self.db.collection(self.demos_collection).document(demo_id)
            doc = doc_ref.get()
            
            if not doc.exists:
                return None
            
            data = doc.to_dict()
            return DemoMetadata(**data)
            
        except Exception as e:
            logger.error(f"Failed to get demo {demo_id}: {e}")
            return None
    
    async def get_demo_html(self, demo_id: str) -> Optional[str]:
        """Get demo HTML content from Cloud Storage"""
        try:
            bucket = self.storage_client.bucket(self.bucket_name)
            blob = bucket.blob(f"demos/{demo_id}/index.html")
            
            if not blob.exists():
                return None
            
            return blob.download_as_text()
            
        except Exception as e:
            logger.error(f"Failed to get HTML for demo {demo_id}: {e}")
            return None
    
    async def increment_view_count(self, demo_id: str):
        """Increment view count and update last viewed timestamp"""
        try:
            doc_ref = self.db.collection(self.demos_collection).document(demo_id)
            doc_ref.update({
                "view_count": firestore.Increment(1),
                "last_viewed": datetime.utcnow()
            })
        except Exception as e:
            logger.warning(f"Failed to update view count for {demo_id}: {e}")
    
    async def list_demos(self, created_by: Optional[str] = None, limit: int = 50) -> List[DemoMetadata]:
        """List demos with optional filtering"""
        try:
            query = self.db.collection(self.demos_collection)
            
            if created_by:
                query = query.where("created_by", "==", created_by)
            
            query = query.where("status", "==", "active")
            query = query.order_by("created_at", direction=firestore.Query.DESCENDING)
            query = query.limit(limit)
            
            docs = query.stream()
            demos = []
            
            for doc in docs:
                try:
                    demos.append(DemoMetadata(**doc.to_dict()))
                except Exception as e:
                    logger.warning(f"Failed to parse demo {doc.id}: {e}")
            
            logger.info(f"Found {len(demos)} demos (created_by={created_by}, limit={limit})")
            return demos
            
        except Exception as e:
            logger.error(f"Failed to list demos: {e}")
            raise  # Propagate error instead of returning empty list
    
    async def delete_demo(self, demo_id: str) -> bool:
        """Delete a demo (soft delete - mark as deleted)"""
        try:
            doc_ref = self.db.collection(self.demos_collection).document(demo_id)
            doc_ref.update({
                "status": "deleted",
                "deleted_at": datetime.utcnow()
            })
            
            logger.info(f"Soft deleted demo {demo_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to delete demo {demo_id}: {e}")
            return False
    
    async def hard_delete_demo(self, demo_id: str) -> bool:
        """Hard delete a demo (remove from storage and database completely)"""
        try:
            # Delete from Cloud Storage
            bucket = self.storage_client.bucket(self.bucket_name)
            blob = bucket.blob(f"demos/{demo_id}/index.html")
            if blob.exists():
                blob.delete()
                logger.info(f"Deleted HTML content for demo {demo_id}")
            
            # Delete from Firestore
            doc_ref = self.db.collection(self.demos_collection).document(demo_id)
            doc_ref.delete()
            
            logger.info(f"Hard deleted demo {demo_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to hard delete demo {demo_id}: {e}")
            return False
    
    async def update_demo_design(self, demo_id: str, new_design: ChatDesign, update_reason: str = None) -> bool:
        """Update demo design configuration and regenerate HTML"""
        try:
            doc_ref = self.db.collection(self.demos_collection).document(demo_id)
            
            # Update design in Firestore
            update_data = {
                "design": new_design.dict(),
                "updated_at": datetime.utcnow()
            }
            
            if update_reason:
                update_data["last_update_reason"] = update_reason
            
            doc_ref.update(update_data)
            
            logger.info(f"Updated design for demo {demo_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to update demo design {demo_id}: {e}")
            return False
    
    async def cleanup_expired_demos(self) -> int:
        """Clean up expired demos (hard delete from storage)"""
        try:
            now = datetime.utcnow()
            query = self.db.collection(self.demos_collection)
            query = query.where("expires_at", "<=", now)
            query = query.where("status", "==", "active")
            
            docs = query.stream()
            deleted_count = 0
            
            for doc in docs:
                try:
                    demo_id = doc.id
                    
                    # Delete from Cloud Storage
                    bucket = self.storage_client.bucket(self.bucket_name)
                    blob = bucket.blob(f"demos/{demo_id}/index.html")
                    if blob.exists():
                        blob.delete()
                    
                    # Update status in Firestore
                    doc.reference.update({
                        "status": "expired",
                        "expired_at": now
                    })
                    
                    deleted_count += 1
                    logger.info(f"Cleaned up expired demo {demo_id}")
                    
                except Exception as e:
                    logger.warning(f"Failed to cleanup demo {doc.id}: {e}")
            
            if deleted_count > 0:
                logger.info(f"Cleaned up {deleted_count} expired demos")
            
            return deleted_count
            
        except Exception as e:
            logger.error(f"Failed to cleanup expired demos: {e}")
            return 0

# Singleton instance
_demo_manager = None

def get_demo_manager() -> DemoManager:
    """Get singleton demo manager instance"""
    global _demo_manager
    if _demo_manager is None:
        _demo_manager = DemoManager()
    return _demo_manager

# Update forward references
DemoMetadata.model_rebuild()

# Session-Scoped Unified Memory Example
# =====================================
# 
# This configuration demonstrates how to set up session-scoped unified memory
# so all agents in a workflow share the same conversation context.

version: "1.0"

# =============================================================================
# GLOBAL MEMORY + SESSION CONFIGURATION
# =============================================================================

# Global BigQuery memory - all agents inherit this
memory:
  backend: "bigquery"
  settings:
    project_id: "enkl-uat"
    dataset_id: "unified_sessions"
    table_id: "workflow_conversations"
    location: "US"
    description: "Session-scoped unified memory for all workflow agents"

# Session-scoped unified memory configuration
session:
  # ðŸŽ¯ CORE UNIFIED MEMORY SETTINGS
  unified_memory: true                # Enable shared memory across agents
  session_strategy: "hybrid"          # Intelligent session management
  scope: "workflow"                   # Share memory within workflow execution
  sharing_strategy: "all"             # All agents see complete context
  
  # ðŸ”„ SESSION PERSISTENCE  
  persist_session: true               # Save session to BigQuery
  session_timeout: 7200               # 2 hours before session expires
  auto_cleanup: true                  # Clean up expired sessions
  
  # ðŸ“Š ENHANCED FEATURES
  enable_analytics: true              # Enable session analytics
  enable_search: true                 # Enable conversation search
  context_window_management: "auto"   # Intelligent context management

# =============================================================================
# AGENTS (All share the unified session memory)
# =============================================================================

agents:
  # Customer Request Analyzer
  - id: "request_analyzer"
    model: "gpt-4o"
    behavior: "analytical"
    system_prompt: |
      You are a customer request analyzer.
      Analyze incoming customer requests and extract key information.
      
      You have access to the complete workflow session memory.
      Store your analysis clearly for other agents to reference.

  # Solution Designer  
  - id: "solution_designer"
    model: "gpt-4o"
    behavior: "helpful"
    system_prompt: |
      You are a solution designer.
      Design solutions based on the analyzed customer request.
      
      You can see the complete request analysis from the session memory.
      Reference the analyzer's findings and build upon them.

  # Technical Validator
  - id: "tech_validator"
    model: "gpt-4o"
    behavior: "analytical"
    system_prompt: |
      You are a technical validator.
      Validate proposed solutions for technical feasibility.
      
      You have access to both the request analysis and solution design
      from the shared session memory. Reference specific details.

  # Response Generator
  - id: "response_generator"
    model: "gpt-4o"
    behavior: "helpful"
    system_prompt: |
      You are a customer response generator.
      Create comprehensive customer responses based on the complete workflow.
      
      You can see the entire session: request analysis, solution design,
      and technical validation. Create responses that reference all findings.

# =============================================================================
# WORKFLOWS WITH UNIFIED MEMORY
# =============================================================================

workflows:
  # Customer Support Workflow
  - id: "customer_support_flow"
    name: "Customer Support with Unified Memory"
    description: "Multi-agent customer support with shared context"
    
    steps:
      - id: "analyze_request"
        agent: "request_analyzer"
        input: "${user_input}"
        output:
          to: "analysis_result"
        
      - id: "design_solution"
        agent: "solution_designer"
        input: "Design a solution based on the request analysis in our session"
        output:
          to: "solution_result"
          
      - id: "validate_technical"
        agent: "tech_validator"
        input: "Validate the proposed solution from our session context"
        output:
          to: "validation_result"
          
      - id: "generate_response"
        agent: "response_generator"
        input: "Generate customer response using all session context"
        output:
          to: "user"

  # Document Processing Workflow
  - id: "document_processing_flow"
    name: "Document Processing with Shared Memory"
    
    steps:
      - id: "extract_content"
        agent: "request_analyzer"  # Reusing for content extraction
        input: "Extract key content from: ${user_input}"
        
      - id: "structure_data"
        agent: "solution_designer"  # Reusing for data structuring
        input: "Structure the extracted content from our session"
        
      - id: "validate_accuracy"
        agent: "tech_validator"
        input: "Validate the structured data accuracy using session context"
        
      - id: "format_output"
        agent: "response_generator"
        input: "Format final output referencing all session work"
        output:
          to: "user"

# =============================================================================
# USAGE EXAMPLES
# =============================================================================

# Python Usage:
# from langswarm.core.config import LangSwarmConfigLoader, WorkflowExecutor
# 
# # Load configuration
# loader = LangSwarmConfigLoader("session_unified_example.yaml")
# workflows, agents, brokers, tools, metadata = loader.load()
# 
# # Execute workflow with unified memory
# executor = WorkflowExecutor(workflows, agents)
# result = executor.run_workflow(
#     "customer_support_flow", 
#     user_input="I need help setting up API authentication for my mobile app"
# )
# 
# # Each agent in the workflow can see:
# # 1. Original user request
# # 2. Previous agent analysis
# # 3. Solution design details  
# # 4. Technical validation results
# # 5. Complete conversation history

# =============================================================================
# BIGQUERY ANALYTICS FOR SESSIONS
# =============================================================================

# Query 1: Session workflow analysis
# SELECT 
#   session_id,
#   COUNT(*) as agent_interactions,
#   STRING_AGG(agent_id ORDER BY timestamp) as agent_sequence,
#   MIN(timestamp) as workflow_start,
#   MAX(timestamp) as workflow_end,
#   TIMESTAMP_DIFF(MAX(timestamp), MIN(timestamp), SECOND) as duration_seconds
# FROM `enkl-uat.unified_sessions.workflow_conversations`
# WHERE DATE(timestamp) = CURRENT_DATE()
# GROUP BY session_id
# ORDER BY workflow_start DESC;

# Query 2: Agent collaboration patterns
# SELECT 
#   agent_id,
#   COUNT(DISTINCT session_id) as sessions_participated,
#   COUNT(*) as total_interactions,
#   AVG(LENGTH(agent_response)) as avg_response_length
# FROM `enkl-uat.unified_sessions.workflow_conversations`
# WHERE timestamp >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY)
# GROUP BY agent_id;

# Query 3: Session success tracking
# SELECT 
#   session_id,
#   CASE 
#     WHEN COUNT(*) = 4 THEN 'Complete Workflow'
#     WHEN COUNT(*) >= 3 THEN 'Partial Workflow'
#     ELSE 'Incomplete'
#   END as workflow_status,
#   COUNT(*) as steps_completed
# FROM `enkl-uat.unified_sessions.workflow_conversations`
# GROUP BY session_id;

# Query 4: Cross-agent referencing analysis
# SELECT 
#   session_id,
#   agent_id,
#   timestamp,
#   CASE 
#     WHEN LOWER(agent_response) LIKE '%session%' 
#       OR LOWER(agent_response) LIKE '%previous%'
#       OR LOWER(agent_response) LIKE '%analysis%'
#       OR LOWER(agent_response) LIKE '%context%'
#     THEN TRUE 
#     ELSE FALSE 
#   END as references_session_context
# FROM `enkl-uat.unified_sessions.workflow_conversations`
# WHERE timestamp >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 1 DAY);

# =============================================================================
# COMPARISON: WITH vs WITHOUT UNIFIED MEMORY
# =============================================================================

# WITHOUT Session-Scoped Unified Memory:
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Agent 1: "User wants API help" â†’ Basic response
# Agent 2: Gets only Agent 1's output â†’ Limited context  
# Agent 3: Gets only Agent 2's output â†’ No original request context
# Agent 4: Gets only Agent 3's output â†’ Completely disconnected from user intent

# WITH Session-Scoped Unified Memory:
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Agent 1: "User wants API help for mobile app authentication" â†’ Detailed analysis
# Agent 2: "Based on Agent 1's analysis of mobile app API auth..." â†’ Full context
# Agent 3: "Validating Agent 2's OAuth solution for the mobile app..." â†’ Complete picture
# Agent 4: "Here's your mobile app API authentication guide..." â†’ Perfect customer response

# =============================================================================
# BENEFITS SUMMARY
# =============================================================================

# âœ… Context Preservation: No information loss between agents
# âœ… Intelligent Collaboration: Agents build on each other's work
# âœ… Better Customer Experience: Responses show understanding of complete request
# âœ… Analytics: Track complete workflow performance
# âœ… Debugging: See exactly how agents collaborate
# âœ… Scalability: Add more agents without breaking context flow